<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="A developers blog">

    <title>MicroHack Fargate - 040 Code</title>

    <link rel="canonical" href="https://040code.github.io//2018/01/30/fargate_with_terraform/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/clean-blog.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <link type="application/atom+xml" rel="alternate" href="https://040code.github.io//feed.xml" title="040 Code" />

    

    
    <link rel="stylesheet" type="text/css" href="/css/asciinema-player.css" />
    <script src="/js/asciinema-player.js"></script>
    


</head>


<body>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">040 Code</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="/">Home</a>
                </li>
                
                  
                  <li>
                      <a href="/author/niek/">Niek Palm</a>
                  </li>


                  
                
                  
                  <li>
                      <a href="/author/maarten/">Maarten Metz</a>
                  </li>


                  
                
                  
                  <li>
                      <a href="/author/jeroen/">Jeroen Knoops</a>
                  </li>


                  
                
            </ul>

        </div>


        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>


    



<!-- Post Header -->
<header class="intro-header" style="background-image: url('/assets/2018-01-30-fargate_with_terraform/img/strijps-containers.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>MicroHack Fargate</h1>
                    
                    <h2 class="subheading">Running serverless containers with Terraform</h2>
                    
                    <span class="meta">Posted by:
                      
                          <a href="/author/niek/">
                            Niek Palm
                          </a>
                          
                      
                      on 2018-01-30</span>
                </div>
            </div>
        </div>
    </div>
</header>



<!-- Post Content -->
<section>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">


        <a class="badge " href="/blog/tag/aws/">Amazon</a><a class="badge " href="/blog/tag/terraform/">Terraform</a><a class="badge " href="/blog/tag/docker/">Docker</a><a class="badge " href="/blog/tag/microhack/">MicroHack</a>


				<p>Last December at the AWS re:invent, AWS announced the new container service platform Fargate. Fargate is integrated to ECS. The key difference is that Fargate does not require you to have EC2 instances running to host your containers, which means we have serverless containers. A drawback is that Fargate is not globally available yet, today Fargate is only available in <code class="highlighter-rouge">us-east-1</code>, see also the <a href="https://aws.amazon.com/about-aws/global-infrastructure/regional-product-services/">list</a> of supported regions. Later in December Fargate also become available in <a href="https://www.terraform.io/">Terraform</a> so time to see how it works.</p>

<p>In this post I will show how to deploy containers to Fargate using Terraform. As example docker image I will use the blog itself. The complete example in available on <a href="https://github.com/npalm/blog_terraform_aws_fargate">GitHub</a>. First I show how you can deploy a container using Terraform to Fargate. In case you would like to experiment with AWS console instead of Terraform you should be able to execute the same steps direct in AWS. Only the VPC part could be a bit tricky, but even that part can be skipped and replaced with the default VPC. In that case you don’t have private subnets available.</p>

<p>Finally I will discuss how a deployment with Fargate in ECS compares to a deployment with EC2 in ECS. And show what steps have to be taken to move the deployment from Fargate to EC2 instances.</p>

<h2 id="prerequisites">Prerequisites</h2>
<p>Before you start you need to have programmatically access to an AWS account and Terraform (0.11+) installed. The tool <a href="http://brewformulas.org/Tfenv">tfenv</a> let you manage multiple terraform version on your system.</p>

<h2 id="deploy-serverless-containers-on-fargate">Deploy serverless containers on Fargate</h2>
<p>Before we can create our containers, we have to create a few infrastructural components. For this example we create an own VPC including public and private subnets. An ECS cluster for our containers, and a CloudWatch log group for centralized logging. The diagram below shows an abstract view of the deployment we are going to create, this view contains two in instead of the 3 availability zones we use.</p>

<p><a href="#">
    <img src="/assets/2018-01-30-fargate_with_terraform/img/ecs-fargate-diagram.png" alt="Fargate" />
</a></p>

<p>We start with defining the VPC, we choose <code class="highlighter-rouge">us-east-1</code> since Fargate is only available in this region. In the blog post <a href="/2017/06/18/terraform-aws-vpc/">Coding a VPC in Terraform</a> you find more details about how this VPC module is structured.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>provider "aws" {
  region  = "us-east-1"
  version = "1.7.1"
}

provider "template" {
  version = "1.0"
}

module "vpc" {
  source  = "npalm/vpc/aws" // https://registry.terraform.io/modules/npalm/vpc/aws
  version = "1.1.0"

  environment = "blog"
  aws_region  = "us-east-1"

  create_private_hosted_zone = "false"

  // us-east-1 is the only region that supports Fargate
  availability_zones = {
    us-east-1 = ["us-east-1a", "us-east-1b", "us-east-1c"]
  }
}

</code></pre></div></div>

<p>Next we define the ECS cluster, and CloudWatch log group. Since we will deploy to Fargate we don’t have to attache EC2 instances to our cluster.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resource "aws_ecs_cluster" "cluster" {
  name = "blog-ecs-cluster"
}

resource "aws_cloudwatch_log_group" "log_group" {
  name = "blog"
}
</code></pre></div></div>
<p>Now the first part is defined we execute a <code class="highlighter-rouge">terraform apply</code> and inpect the results.</p>

<asciinema-player src="/assets/2018-01-30-fargate_with_terraform/asciinema/fargate-terraform-1.json" cols="166" rows="15" autoplay="true" loop="true" speed="1.5">
</asciinema-player>

<p>The next step is to deploy the docker image with the blog. In ECS you deploy a docker container with a task. And your task will be managed by a service. First we create the task definition which contains the container deployment definition as well. Fargate is using <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html">awsvpc as networking mode</a>, in this mode each task definiton gets its own private ip address. This network mode requires a role for the task execution. In case you create your definition through the Amazon console a service linked role will be created for you. We will create this role also via code.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data "aws_iam_policy_document" "ecs_tasks_execution_role" {
  statement {
    actions = ["sts:AssumeRole"]

    principals {
      type        = "Service"
      identifiers = ["ecs-tasks.amazonaws.com"]
    }
  }
}

resource "aws_iam_role" "ecs_tasks_execution_role" {
  name               = "blog-ecs-task-execution-role"
  assume_role_policy = "${data.aws_iam_policy_document.ecs_tasks_execution_role.json}"
}

resource "aws_iam_role_policy_attachment" "ecs_tasks_execution_role" {
  role       = "${aws_iam_role.ecs_tasks_execution_role.name}"
  policy_arn = "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy"
}

</code></pre></div></div>

<p>We have defined the execution rol for the task, next we define the task definion. This task definition consist of two parts. First we define a container definition via a <code class="highlighter-rouge">template_file</code>. In this container definition you see container port 80 is mapped to host port 80, the task will get its own private IP. And after that we define the task definition self. The following settings are required for a task that will run in Fargate: requires_compatibilities, network_mode, cpu and memory.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data "template_file" "blog" {
  template = &lt;&lt;EOF
  [
    {
      "essential": true,
      "image": "npalm/040code.github.io:latest",
      "name": "blog",
      "portMappings": [
        {
          "hostPort": 80,
          "protocol": "tcp",
          "containerPort": 80
        }
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "blog",
          "awslogs-region": "us-east-1",
          "awslogs-stream-prefix": "040code"
        }
      }
    }
  ]

  EOF
}

resource "aws_ecs_task_definition" "task" {
  family                   = "blog-blog"
  container_definitions    = "${data.template_file.blog.rendered}"
  network_mode             = "awsvpc"
  cpu                      = "256"
  memory                   = "512"
  requires_compatibilities = ["FARGATE"]
  execution_role_arn       = "${aws_iam_role.ecs_tasks_execution_role.arn}"
}
</code></pre></div></div>
<p>Time to verify the code is working by executing a <code class="highlighter-rouge">terraform apply</code></p>

<asciinema-player src="/assets/2018-01-30-fargate_with_terraform/asciinema/fargate-terraform-2.json" cols="166" rows="15" autoplay="true" loop="true" speed="1.0">
</asciinema-player>

<p><a href="#">
    <img src="/assets/2018-01-30-fargate_with_terraform/img/container-definition.png" alt="Fargate" />
</a></p>

<p>We have still nothing running but you can already see the different parts in de AWS console. We have now a VPC, CloudWatch log group, ECS cluster and task definition available. The next logical step in de AWS console would be to create the service, and find out at the latest step that you need to create a load balancer first. So in code we will define the load balancer first. The load balancer will route traffic via HTTP to the container.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resource "aws_security_group" "alb_sg" {
  name   = "blog-blog-alb-sg"
  vpc_id = "${module.vpc.vpc_id}"

  ingress {
    protocol    = "tcp"
    from_port   = 80
    to_port     = 80
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port = 0
    to_port   = 0
    protocol  = "-1"

    cidr_blocks = ["0.0.0.0/0"]
  }
}

resource "aws_alb" "main" {
  internal        = "false"
  subnets         = ["${module.vpc.public_subnets}"]
  security_groups = ["${aws_security_group.alb_sg.id}"]
}

resource "aws_alb_listener" "main" {
  load_balancer_arn = "${aws_alb.main.id}"
  port              = 80
  protocol          = "HTTP"

  default_action {
    target_group_arn = "${aws_alb_target_group.main.id}"
    type             = "forward"
  }
}

</code></pre></div></div>

<p>We connect a target group to the load balancer. The same target group will be used later in the service, the service can register itself to the target group with the actual IP address once up and running. For the target group we have to specify the target type <code class="highlighter-rouge">ip</code> and not <code class="highlighter-rouge">instance</code> since containers running in Fargate will get their own IP. Actually this not Fargate but <code class="highlighter-rouge">awsvpc</code> behavior.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resource "aws_alb_target_group" "main" {
  port        = "80"
  protocol    = "HTTP"
  vpc_id      = "${module.vpc.vpc_id}"
  target_type = "ip"
}

output "blog_url" {
  value = "http://${aws_alb.main.dns_name}"
}

</code></pre></div></div>
<p>Again we verify our new code by executing a <code class="highlighter-rouge">terraform apply</code>.</p>

<asciinema-player src="/assets/2018-01-30-fargate_with_terraform/asciinema/fargate-terraform-3.json" cols="166" rows="15" autoplay="true" loop="true" speed="1.5">
</asciinema-player>

<p>We are almost there, next we define the service. A task running in in network mode <code class="highlighter-rouge">awsvpc</code>, requires a service that defines a network configuration. In the networking configuration we define a security group to control access to our containers, and we define the subnets in which the containers are hosted.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resource "aws_security_group" "awsvpc_sg" {
  name   = "blog-awsvpc-cluster-sg"
  vpc_id = "${module.vpc.vpc_id}"

  ingress {
    protocol  = "tcp"
    from_port = 0
    to_port   = 65535

    cidr_blocks = [
      "${module.vpc.vpc_cidr}",
    ]
  }

  egress {
    from_port   = 0
    to_port     = 65535
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags {
    Name        = "blog-ecs-cluster-sg"
    Environment = "blog"
  }
}
</code></pre></div></div>
<p>The last resource to create is the service. In the service we connect the task, load balancer and security group together. By setting the launch type to <code class="highlighter-rouge">FARGATE</code> we tell Amazon to deploy the container to Fargate.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
resource "aws_ecs_service" "service" {
  name            = "blog"
  cluster         = "${aws_ecs_cluster.cluster.id}"
  task_definition = "${aws_ecs_task_definition.task.arn}"
  desired_count   = 1

  load_balancer = {
    target_group_arn = "${aws_alb_target_group.main.arn}"
    container_name   = "blog"
    container_port   = 80
  }

  launch_type = "FARGATE"

  network_configuration {
    security_groups = ["${aws_security_group.awsvpc_sg.id}"]
    subnets         = ["${module.vpc.private_subnets}"]
  }

  depends_on = ["aws_alb_listener.main"]
}
</code></pre></div></div>
<p>That is the last part of coding, run <code class="highlighter-rouge">terraform apply</code> and inspect the result.</p>

<asciinema-player src="/assets/2018-01-30-fargate_with_terraform/asciinema/fargate-terraform-4.json" cols="166" rows="15" autoplay="true" loop="true" speed="1.5">
</asciinema-player>

<p>That is all, we have now our blog running as serverless container in AWS Fargate.</p>

<p><a href="#">
    <img src="/assets/2018-01-30-fargate_with_terraform/img/ecs-fargate.png" alt="Fargate" />
</a></p>

<h2 id="mixing-ec2-and-fargate-on-ecs">Mixing EC2 and Fargate on ECS</h2>
<p>Great we have now our container running in ECS with Fargate but what if we would like to move the container to a dedicated EC2 instances in ECS. Or what if we need that are not available in in Fargate, such as a volume mount? How difficult would it be to move our containers to an ECS cluster with dedicated EC2 instances? Time to do an experiment to see how difficult is is.</p>

<p>First we refactor the above code to some <a href="https://github.com/npalm/terraform-aws-ecs-service">generic ecs service modules</a> to be able to define our services with just a few lines of code. This module replaces all code of defining the load balancer, service and task. It still requires a VPC, ECS cluster, CloudWatch logging group, awsvpc security group and execution role. In the code you see a similar deployment of the blog but now with a generic ECS service module.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>locals {
  fg_container_name = "blog"
  fg_container_port = "80"
}

data "template_file" "blog" {
  template = "${file("${path.root}/task-definition/blog.json")}"

  vars {
    container_name   = "${local.fg_container_name}"
    container_port   = "${local.fg_container_port}"
    log_group_name   = "${aws_cloudwatch_log_group.log_group.name}"
    log_group_region = "${var.aws_region}"
    log_group_prefix = "blog"
  }
}

module "blog-fg" {
  source = "npalm/ecs-service/aws" // https://registry.terraform.io/modules/npalm/ecs-service/aws

  service_launch_type  = "FARGATE"
  service_name          = "${local.fg_container_name}"

  vpc_id       = "${module.vpc.vpc_id}"
  vpc_cidr     = "${module.vpc.vpc_cidr}"
  lb_subnetids = "${module.vpc.public_subnets}"
  ecs_cluster_id = "${aws_ecs_cluster.cluster.id}"
  lb_internal = false

  task_definition = "${data.template_file.blog.rendered}"
  task_cpu        = "256"
  task_memory     = "512"

  awsvpc_task_execution_role_arn = "${aws_iam_role.ecs_tasks_execution_role.arn}"
  awsvpc_service_security_groups = ["${aws_security_group.awsvpc_sg.id}"]
  awsvpc_service_subnetids       = "${module.vpc.private_subnets}"

  lb_target_group = {
    container_name = "${local.fg_container_name}"
    container_port = "${local.fg_container_port}"
  }

  lb_listener = {
    port     = 80
    protocol = "HTTP"
  }
}
</code></pre></div></div>

<p>We still have our container not running in ECS on EC2 instances. For that we first have to create EC2 instances that will be attached to the same ECS cluster. For more details about create the EC2 instances see the <a href="https://github.com/npalm/terraform-aws-ecs-instances">ecs instance repo</a> on GitHub.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>locals {
  key_name = "blog"
  environment = "dev"
}

resource "aws_key_pair" "key" {
  key_name   = "${local.key_name}"
  public_key = "${file("id_rsa")}"
}

module "ecs_instances" {
  source  = "npalm/ecs-instances/aws" // https://registry.terraform.io/modules/npalm/ecs-instances/aws

  ecs_cluster_name = "${aws_ecs_cluster.cluster.name}"
  aws_region       = "${local.aws_region}"
  environment      = "${local.environment}"
  key_name         = "${local.key_name}"
  vpc_id           = "${module.vpc.vpc_id}"
  vpc_cidr         = "${module.vpc.vpc_cidr}"
  subnets          = "${module.vpc.private_subnets}"
}
</code></pre></div></div>

<p>Now we have our EC2 instances available we only have to copy the the blog module above and change the launch type to <code class="highlighter-rouge">EC2</code>, and our container will be deployed to a dedicated EC2 instance.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
module "blog-ec" {
  source = "npalm/ecs-service/aws" // https://registry.terraform.io/modules/npalm/ecs-service/aws

  service_launch_type  = "FARGATE"
  service_name          = "blog-ec2"

  ... SAME AS ABOVE ...
}
</code></pre></div></div>

<p>That is all, all sample code is available at <a href="https://github.com/npalm/blog_terraform_aws_fargate">GitHub</a> see subdir <code class="highlighter-rouge">fargate-ec2</code>. Time to run a <code class="highlighter-rouge">terraform apply</code> to see if it works.</p>

<asciinema-player src="/assets/2018-01-30-fargate_with_terraform/asciinema/fargate-ec2.json" cols="166" rows="15" autoplay="true" loop="true" speed="1.5">
</asciinema-player>

<p>In the output you will find the two endpoint links to the blogs. After a few minutes both links will be active. You can also see the service running on the Amazon console, simply navigate to the ECS console and select the cluster. You should see now one service on Fargate and the second one on EC2.</p>

<p><a href="#">
    <img src="/assets/2018-01-30-fargate_with_terraform/img/ecs-fargate-2.png" alt="Fargate" />
</a></p>


                <hr>

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2017/12/09/runners-on-the-spot/" data-toggle="tooltip" data-placement="top" title="Runners on the Spot">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2018/02/14/service-discovery/" data-toggle="tooltip" data-placement="top" title="Service Discovery on AWS">Next Post &rarr;</a>
                    </li>
                    
                </ul>

            </div>
        </div>
    </div>
</section>




<hr>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- <ul class="list-inline text-center">
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="https://www.linkedin.com/in/niekpalm">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://twitter.com/niekos77">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    <li>
                        <a href="https://github.com/npalm">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                </ul> -->
                <p class="copyright text-muted">Copyright &copy; 040 Code 2018</p>
            </div>
        </div>
    </div>
</footer>

<!-- Disqus -->



<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/clean-blog.min.js "></script>


    
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-97020149-1', 'auto');
  ga('send', 'pageview');

</script>



</body>

</html>
