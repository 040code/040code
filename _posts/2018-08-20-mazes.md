---
layout:          post
title:           "Maze Generation"
subtitle:        "Generating Mazes from the REPL"
authors:         [maarten]
header-img:      "img/htc-roof.jpg"
tags:            [clojure, functional]
published:       true
---

## Introduction

During my summer holiday, in between long walks and nice food & drinks, I felt
like building something, like for instance writing some code for fun.
Unfortunately, I didn't bring my laptop. Luckily, [Mike
Fikes](https://twitter.com/mfikes) created a [ClojureScript REPL for
ios](https://itunes.apple.com/us/app/replete/id1013465639).

Saving work is not possible in this REPL, there are no debugging capabilities,
no code completion, no test runners ... just a REPL (or a Read Eval Print Loop):
35 characters wide in portrait mode, 79 characters wide in landscape mode. To
give you an idea of my 'Integrated Development Environment' and the resulting
mazes, I recorded a short screen cast:

<iframe src="https://player.vimeo.com/video/258632942" width="640" height="732" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

At home, I created a gist containing all 70 lines of [maze
code](https://gist.github.com/mmzsource/ee88b93a3829f98fcb6188f2f2162fcf). In
this blog I'm going to explain the concepts and code.

## Grids, Cells and Neighbours

First of all, we'll need a grid and a coordinate system to point to individual
cells in the grid. The reason is that most maze generators expect to be able to
traverse a grid and lookup information about cells and neighbours of cells.

A grid can be modeled as a vector of vectors, representing rows and columns:

```Clojure
(def grid
  [[1 2 3]
   [4 5 6]
   [7 8 9]])
```

A cell can be pinpointed by its [row col] coordinate which matches perfectly
with the `get-in` function in clojure. This `get-in` function is used to find
items in nested data structures. For instance, `(get-in grid [2 1])` will result
in the value `8`.

To find the neighbours of a cell, I created a couple of helper functions:

```Clojure
(defn top    [[row col]] [(dec row) col])
(defn bottom [[row col]] [(inc row) col])
(defn left   [[row col]] [row (dec col)])
(defn right  [[row col]] [row (inc col)])
```

The function argument is destructured (taken apart and named) and the `top`,
`bottom`, `left` or `right` neighbour coordinate is calculated by `inc`rementing
or `dec`rementing the row or column number. For instance, `(top [1 1])` results
in the value `[0 1]`.

Using the `juxt` function we can now calculate all neighbours in one go. `juxt`
takes a variable number of functions as arguments and returns a new function.
This new function returns a vector containing the result of applying each
function to the arguments provided. So for instance `((juxt top bottom left
right) [1 1])` results in the value `[[0 1] [2 1] [1 0] [1 2]]`.

Unfortunately, these functions don't care about the grid. `((juxt top bottom
left right) [0 0])` will happily return `[[-1 0] [1 0] [0 -1] [0 1]]` containing
cell coordinates outside the grid. Therefore, in order to calculate all
neighbours **in** the grid, we need to filter out the ones that are not part of
the grid. This results in the following `neighbours` function:

```Clojure
(defn neighbours [grid cell]
  (filter #(get-in grid %) ((juxt top bottom left right) cell)))
```

## Mazes and Cells

Now working with the grid is easy, let's move on to the maze. A maze is
basically a grid, augmented with some information to determine if borders
between cells are open or closed. That information can be easily stored in the
cells themselves.

I liked the approach [Mark
Bastian](http://fn-code.blogspot.com/2015/04/a-maze-ing-mazes-with-clojure.html)
took: in a cell simply list the coordinates of neighbours the cell is connected
to. A cell can therefore be a collection of coordinates. It can even be a set
`#{}`, since duplicating neighbour coordinates is useless. A 2x2 'maze' with all
borders closed looks like this:

```Clojure
[[#{} #{}]
 [#{} #{}]]
```

A 2x2 'maze' with an open border between the 2 left cells looks like this:

```Clojure
[[#{[1 0]} #{}]
 [#{[0 0]} #{}]]
```

The two connected cells, 'point' to each other. It would be convenient to have a
function that updates the grid when a border needs to be removed between 2
cells:

```Clojure
(defn remove-border [grid c1 c2]
  (-> grid
      (update-in c1 conj c2)
      (update-in c2 conj c1)))
```

## Maze Generation

Now it's time for the maze generation. Luckily I had a copy of the ['Mazes for
Programmers
book'](https://www.amazon.com/Mazes-Programmers-Twisty-Little-Passages/dp/1680500554)
on my phone. Since I liked the texture of the mazes coming out of the
recursive backtracker algorithm, I decided to implement that one.

The algorithm can start on any cell on the grid and I decided to start on `[0
0]` every single time. Every cell that is visited by the algorithm is pushed on
a stack which I have called the `backtrackstack`. The cell on top of the stack
is considered the current cell.

From the current cell, a path is created (`remove-border`) to a randomly
selected previously unvisited neighbour. An unvisited neighbour can easily be
detected, since it's simply an empty set `#{}`. That previously unvisited cell
(`next` in my code) is also pushed unto the stack. This process repeats
continuously until a cell is visited that has no unvisited neighbours. At that
point, that dead-end cell is popped of the stack, making the previous cell the
current cell. Again, the algorithm will check if this cell has unvisited
neighbours and will either create a path to that neighbour or pop another cell
from the backtrackstack. This will continue until every cell has been visited
and the `backtrackstack` is empty.

```Clojure
(defn find-unvisited-neighbours [grid cell]
  (let [n (neighbours grid cell)]
    (filter #(empty? (get-in grid %)) n)))

(defn generate-maze [rows cols]
  (loop [maze           (create-grid rows cols)
         backtrackstack '([0 0])]
    (if (empty? backtrackstack)
      (print-maze maze)
      (let [unvn (find-unvisited-neighbours maze (first backtrackstack))]
        (if (empty? unvn)
          (recur maze (rest backtrackstack))
          (let [next (rand-nth unvn)]
            (recur
             (remove-border maze (first backtrackstack) next)
             (conj backtrackstack next))))))))
```

Fingers crossed:

```Clojure
 (generate-maze 4 4)

[[#{[1 0]} #{[0 2]} #{[0 3] [0 1]} #{[1 3] [0 2]}]
 [#{[0 0] [2 0]} #{[2 1] [1 2]} #{[1 1] [1 3]} #{[2 3] [0 3] [1 2]}]
 [#{[1 0] [3 0]} #{[2 2] [1 1]} #{[2 1] [3 2]} #{[3 3] [1 3]}]
 [#{[2 0] [3 1]} #{[3 0] [3 2]} #{[2 2] [3 1]} #{[2 3]}]]

 (generate-maze 4 4)

[[#{[0 1]} #{[0 0] [0 2]} #{[1 2] [0 1]} #{[1 3]}]
 [#{[1 1] [2 0]} #{[1 0] [1 2]} #{[1 1] [0 2]} #{[2 3] [0 3]}]
 [#{[1 0] [2 1]} #{[2 0] [3 1]} #{[2 3]} #{[2 2] [3 3] [1 3]}]
 [#{[3 1]} #{[3 0] [2 1] [3 2]} #{[3 3] [3 1]} #{[2 3] [3 2]}]]

 (generate-maze 6 4)

[[#{[1 0]} #{[0 2]} #{[0 3] [0 1]} #{[1 3] [0 2]}]
 [#{[0 0] [2 0]} #{[2 1] [1 2]} #{[1 1] [1 3]} #{[2 3] [0 3] [1 2]}]
 [#{[1 0] [3 0]} #{[1 1] [3 1]} #{[3 2]} #{[3 3] [1 3]}]
 [#{[2 0] [3 1]} #{[3 0] [2 1]} #{[2 2] [4 2]} #{[4 3] [2 3]}]
 [#{[4 1] [5 0]} #{[4 0]} #{[4 3] [5 2] [3 2]} #{[3 3] [4 2]}]
 [#{[5 1] [4 0]} #{[5 2] [5 0]} #{[4 2] [5 3] [5 1]} #{[5 2]}]]
```

Nice! Now the only thing left is printing a more human friendly view of this
maze.

## Maze Printing

First, the top of the maze is printed:

```Ascii
`+---+---+---+`
```

Then for every row 2 passes over the cells have to be made. The first pass
determines if there should be a border between the current cell and its `right`
neighbour, resulting in something like this:

```Ascii
+---+---+---+---+
|           |   |
```

The second pass over the row determines if there should be a border between the
current cell and its `bottom` neighbour, for instance resulting in this:

```Ascii
+---+---+---+---+
|           |   |
+---+---+   +   +
```

After repeating this for all rows, a maze like this is printed:

```Ascii
+---+---+---+---+
|           |   |
+---+---+   +   +
|       |       |
+   +   +---+   +
|   |       |   |
+   +---+   +   +
|       |       |
+---+---+---+---+
```

The code:

```Clojure
(defn right-open-border? [maze cell]
  (contains? (get-in maze (right cell)) cell))

(defn bottom-open-border? [maze cell]
  (contains? (get-in maze (bottom cell)) cell))

(defn print-cell-body [maze cell]
  (if (right-open-border? maze cell)
    "    "
    "   |"))

(defn print-cell-bottom [maze cell]
  (if (bottom-open-border? maze cell)
    "   +"
    "---+"))

(defn print-maze [maze]
  (let [result (atom [])
        rows   (range (count maze))
        cols   (range (count (get-in maze [0])))]
    (swap! result conj "+" (repeat (count cols) "---+") "\n")
    (doseq [row rows]
      (swap! result conj "|")
      (doseq [col cols]
        (swap! result conj (print-cell-body maze [row col])))
      (swap! result conj "\n" "+")
      (doseq [col cols]
        (swap! result conj (print-cell-bottom maze [row col])))
      (swap! result conj "\n"))
    (println (s/join (flatten @result)))))
```

Finally, we can print all the mazes we want (within the restrictions of your
screen size):

```Clojure
(generate-maze 4 4)

+---+---+---+---+
|   |           |
+   +   +   +---+
|   |   |       |
+   +---+---+   +
|   |       |   |
+   +   +   +   +
|       |       |
+---+---+---+---+

(generate-maze 4 4)

+---+---+---+---+
|       |       |
+---+   +   +   +
|   |   |   |   |
+   +   +---+   +
|   |       |   |
+   +---+   +   +
|               |
+---+---+---+---+

(generate-maze 8 18)

+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|   |               |   |       |                   |       |           |
+   +   +   +---+   +   +   +   +   +---+   +---+   +   +   +---+---+   +
|   |   |   |   |   |   |   |       |   |   |           |           |   |
+   +---+   +   +   +   +   +---+---+   +   +---+---+---+---+---+   +   +
|       |   |       |   |   |           |           |   |           |   |
+---+   +   +   +---+   +   +   +---+---+   +---+   +   +   +---+---+   +
|   |       |   |       |   |   |       |   |       |       |           |
+   +---+---+   +   +   +   +   +   +   +---+   +---+   +---+   +   +   +
|           |   |   |   |       |   |           |   |   |   |   |   |   |
+   +---+---+   +   +   +   +---+   +---+---+---+   +   +   +   +   +   +
|   |           |   |       |       |   |           |   |       |   |   |
+   +   +---+---+---+---+   +   +---+   +   +---+   +   +---+   +   +   +
|   |   |               |   |       |   |       |   |       |   |   |   |
+   +   +---+   +---+   +---+---+   +   +---+   +   +---+   +---+   +   +
|               |                   |           |                   |   |
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
```

## Conclusion

So there you have it folks, a maze generator build with nothing but a REPL on a
phone. I really enjoyed the puzzle and the small successes while working in the
REPL. I hope you enjoyed this recap.

I'd like to thanks Mike Fikes for his excellent REPL, Mark Bastian for the
inspiration for the maze data structure and Jamis Buck for his lovely 'Mazes for
programmers' book.

I'm happy to be working in Emacs with the excellent clojure CIDER plugin again.
During my holiday I visited a picturesque CIDRE factory in France. Cheers!

<a href="#">
    <img src="{{ site.baseurl }}/img/mazes/CIDER.jpg"
    alt="CIDER factory">
</a>

Please share your comments, suggestions and thoughts about this blog post on
[twitter.com/mmz_](https://twitter.com/mmz_). Thanks for reading and Happy
Coding!

## Links

-
